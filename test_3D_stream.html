<!DOCTYPE html >
<html>
<head>
<meta http-equiv="X-UA-Compatible" content="chrome=1"/>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<title>Visual CAM</title>
<script src="webapp/libs/require.js"></script>
<script src="webapp/config.js"></script>
<script>
    requirejs.config({
        baseUrl: 'webapp'
    });
</script>
<link rel="shortcut icon" href="webapp/images/icon_fraise_48.png"/>
<link rel="stylesheet" href="webapp/twoDView.css" type="text/css">
<link rel="stylesheet" href="webapp/threeDView.css" type="text/css">
<link rel="stylesheet" href="webapp/libs/bootstrap/css/bootstrap.min.css">
<link rel="stylesheet" href="webapp/libs/font-awesome-4.2.0/css/font-awesome.min.css">
<style>

    body, html {
        height: 100%;
        width: 100%;
        margin: 0;
        padding: 0;
        background: #fafafa;
        color: #444;
    }

    body {
        font-family: sans-serif;
        display: flex;
        flex-direction: column;
    }

    canvas {
        flex: 1;
    }

    .moving {
        cursor: move;
    }
</style>
<script>
    require(['jQuery', 'THREE', 'Piecon', 'cnc/cam/3D/toolProfile', 'cnc/cam/3D/modelProjector', 'libs/threejs/STLLoader',
                'libs/threejs/postprocessing/EffectComposer', 'libs/threejs/postprocessing/RenderPass',
                'libs/threejs/postprocessing/ShaderPass', 'libs/threejs/OrbitControls',
                'libs/threejs/postprocessing/CopyShader'],
            function ($, THREE, Piecon, toolProfile, ModelStage, STLLoader, EffectComposer, RenderPass, ShaderPass, OrbitControls, CopyShader) {
                if (window['Notification'] && Notification.permission === 'default') {
                    Notification.requestPermission(function (permission) {
                        console.log('Notification.permision', permission);
                    });
                }
                var $container = $('body');
                var renderer = new THREE.WebGLRenderer({antialias: false, alpha: true, precision: 'highp', autoClear: false, preserveDrawingBuffer: true});
                $container.append(renderer.domElement);
                var outputWidth = $container.width();
                var outputHeight = $container.height();
                renderer.sortObjects = false;
                renderer.setSize(outputWidth, outputHeight);
                renderer.setViewport(0, 0, outputWidth, outputHeight);
                new STLLoader().load('webapp/samples/soap.stl', function (geometry) {
                    function draw() {
                        displayGeometry(geometry);
                    }

                    draw();
                });


                function displayGeometry(geometry) {
                    var modelStage = new ModelStage();
                    modelStage.setGeometry(geometry);
                    var toolSamples = 30;
                    var sampleRate = 30;
                    var toolradius = toolSamples / sampleRate;
                    var profile = toolProfile.createSphericalTool(toolSamples, modelStage.zRatio, toolradius, 0);
                    var minX = Math.floor(modelStage.modelBbox.min.x * sampleRate);
                    var maxX = Math.ceil(modelStage.modelBbox.max.x * sampleRate);
                    var minY = Math.floor(modelStage.modelBbox.min.y * sampleRate);
                    var maxY = Math.ceil(modelStage.modelBbox.max.y * sampleRate);

                    function setCameraPix(minX, maxX, minY, maxY) {
                        modelStage.setCamera(minX / sampleRate, maxX / sampleRate, minY / sampleRate, maxY / sampleRate);
                    }

                    function setTilePos(x, y) {
                        setCameraPix(minX + x - toolSamples, minX + x + tileSizeX + toolSamples, minY + y - toolSamples, minY + y + tileSizeY + toolSamples);
                    }

                    var globalWidth = maxX - minX;
                    var globalHeight = maxY - minY;
                    var pixelsPerTile = 30000000;
                    var tileArea = pixelsPerTile / (4 * toolSamples * toolSamples);
                    var tileSizeX = Math.ceil(Math.sqrt(tileArea));
                    var tileSizeY = Math.ceil(Math.sqrt(tileArea));
                    console.log(globalWidth, globalHeight, tileSizeX, tileSizeY);
                    console.log('tile area', tileArea);
                    console.log('pixels per tile', toolSamples * toolSamples * 4 * tileSizeX * tileSizeY);
                    console.log('total pixels', toolSamples * toolSamples * 4 * globalWidth * globalHeight);
                    var modelBuffer = new THREE.WebGLRenderTarget(tileSizeX + 2 * toolSamples, tileSizeY + 2 * toolSamples,
                            {minFilter: THREE.NearestFilter, magFilter: THREE.NearestFilter, type: THREE.UnsignedByteType});

                    var toolTexture = new THREE.DataTexture(new Float32Array(profile), toolSamples, 1, THREE.LuminanceFormat, THREE.UnsignedByteType, THREE.UVMapping, THREE.ClampToEdgeWrapping, THREE.ClampToEdgeWrapping, THREE.NearestFilter, THREE.NearestFilter);

                    var minkowskiPass = new ShaderPass({
                        uniforms: {
                            tDiffuse: {type: 't'},
                            toolProfile: {type: 't', value: toolTexture},
                            toolToPartRatio: {type: 'v2', value: new THREE.Vector2(toolSamples / modelBuffer.width, toolSamples / modelBuffer.height)},
                            terrainRatio: {type: 'v2', value: new THREE.Vector2(tileSizeX / modelBuffer.width, tileSizeY / modelBuffer.height)},
                            terrainTranslation: {type: 'v2', value: new THREE.Vector2(toolSamples / modelBuffer.width, toolSamples / modelBuffer.height)}
                        },
                        defines: {
                            radialSamples: toolSamples
                        },
                        vertexShader: [
                            'varying vec2 vUv;',
                            'void main() {',
                            '   vUv = uv;',
                            '   gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);',
                            '}'
                        ].join('\n'),
                        fragmentShader: [
                            'uniform sampler2D tDiffuse;',
                            'uniform sampler2D toolProfile;',
                            'uniform vec2 toolToPartRatio;',
                            'uniform vec2 terrainRatio;',
                            'uniform vec2 terrainTranslation;',
                            'varying vec2 vUv;',
                            'highp float factor = (exp2(24.0) - 1.0) / exp2(24.0);',
                            'vec3 EncodeFloatRGB(highp float v) {',
                            '   vec3 enc = fract(vec3(1.0, 255.0, 255.0 * 255.0) * factor * v);',
                            '   enc -= enc.yzz * vec3(1.0 / 255.0, 1.0 / 255.0, 0.0);',
                            '   return enc;',
                            '}',
                            'highp float DecodeFloatRGB(vec3 rgb) {',
                            '   return dot(rgb, vec3(1.0, 1.0 / 255.0, 1.0 / 255.0 / 255.0)) / factor;',
                            '}',
                            'highp float readHeight(vec2 pos) {',
                            '   highp vec4 color = texture2D(tDiffuse, terrainRatio * vUv + terrainTranslation + pos * toolToPartRatio);',
                            '   highp float displacement = texture2D(toolProfile, vec2(length(pos), 0.0)).r;',
                            '   return DecodeFloatRGB(color.rgb) - displacement;',
                            '}',
                            'void main() {',
                            '   highp int radiusSquared = radialSamples * radialSamples;',
                            '   highp float sum = readHeight(vec2(0.0, 0.0));',
                            '   for (int i = -radialSamples; i <= radialSamples; i++)',
                            '       for (int j = -radialSamples; j <= radialSamples; j++)',
                            '           if (i * i + j * j <= radiusSquared)',
                            '               sum = max(sum, readHeight(vec2(i, j) / float(radialSamples)));',
                            '   gl_FragColor = vec4(EncodeFloatRGB(sum), 1.0);',
                            '}'].join('\n')
                    });
                    var minkowskiBuffer = new THREE.WebGLRenderTarget(tileSizeX, tileSizeY,
                            {minFilter: THREE.NearestFilter, magFilter: THREE.NearestFilter, type: THREE.UnsignedByteType});

                    var copyPass = new ShaderPass(CopyShader);
                    copyPass.quad.geometry.applyMatrix(new THREE.Matrix4().makeTranslation(1, 1, 0));
                    var matrix = new THREE.Matrix4().makeScale(0.5 * tileSizeX, 0.5 * tileSizeY, 1);
                    copyPass.quad.geometry.applyMatrix(matrix);
                    copyPass.camera.left = 0;
                    copyPass.camera.right = globalWidth;
                    copyPass.camera.bottom = 0;
                    copyPass.camera.top = globalHeight;
                    copyPass.camera.updateProjectionMatrix();
                    copyPass.renderToScreen = true;
                    renderer.autoClear = false;

                    var sequence = [];
                    for (var j = 0; j < globalHeight; j += tileSizeY)
                        for (var i = 0; i < globalWidth; i += tileSizeX)
                            sequence.push([i, j]);
                    var resultBuffer = new Float32Array(globalHeight * globalWidth);
                    var resultTile = new Uint8Array(tileSizeX * tileSizeY * 4);
                    var worker = new Worker('worker.js');
                    var factor = (Math.pow(2, 24.0) - 1.0) / Math.pow(2, 24.0);

                    function decodeFloatRgb(r, g, b) {
                        return  (r / 255 + g / 255 / 255 + b / 255 / 255 / 255 ) / factor;
                    }

                    function copyResultTileToResultBuffer(x, y) {
                        for (var j = 0; j < tileSizeY; j++)
                            for (var i = 0; i < tileSizeX; i++) {
                                var pixIndex = ((j * tileSizeX + i) * 4);
                                resultBuffer[(y + j) * globalWidth + i + x] = decodeFloatRgb(resultTile[pixIndex], resultTile[pixIndex + 1], resultTile[pixIndex + 2]);
                            }
                    }

                    var percentage = null;

                    function drawTile(sequenceIndex) {
                        if (sequenceIndex < sequence.length) {
                            var newPercentage = Math.round(sequenceIndex / sequence.length * 25) * 4;
                            if (newPercentage != percentage)
                                Piecon.setProgress(newPercentage);
                            percentage = newPercentage;
                            var x = sequence[sequenceIndex][0];
                            var y = sequence[sequenceIndex][1];
                            setTilePos(x, y);
                            var gl = renderer.getContext();
                            modelStage.render(renderer, modelBuffer);
                            minkowskiPass.render(renderer, minkowskiBuffer, modelBuffer);
                            copyPass.quad.position.x = x;
                            copyPass.quad.position.y = y;
                            copyPass.render(renderer, null, minkowskiBuffer);
                            renderer.setRenderTarget(minkowskiBuffer);
                            gl.readPixels(0, 0, tileSizeX, tileSizeY, gl.RGBA, gl.UNSIGNED_BYTE, resultTile);
                            //by keeping this loop in the main thread, I think we leaving some time for hte GPU to breathe.
                            copyResultTileToResultBuffer(x, y);
                            //setTimeout is not throttled in workers
                            $(worker).one('message', function () {
                                drawTile(sequenceIndex + 1);
                            });
                            worker.postMessage('ping');
                        } else {
                            console.timeEnd('computation');
                            Piecon.reset();
                            if (window['Notification'] && document['visibilityState'] == 'hidden')
                                new Notification("Computation is done.", {icon: 'webapp/images/icon_fraise_48.png'})
                        }
                    }

                    Piecon.setOptions({
                        color: '#752D2D', // Pie chart color
                        background: '#A9BBD1', // Empty pie chart color
                        shadow: '#849DBD'
                    });
                    console.time('computation');
                    drawTile(0);
                }
            });
</script>
</head>
<body>
<div class="btn-toolbar" role="toolbar">

</div>
</body>

</html>
