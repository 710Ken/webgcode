<!doctype html>
<html>
<head>
    <meta http-equiv="X-UA-Compatible" content="chrome=1"/>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>CNC Text Tool</title>
    <script src="webapp/libs/jquery.min.js"></script>
    <script src="webapp/libs/svg.js"></script>
    <script src="webapp/libs/jquery.mousewheel.js"></script>
    <script src="webapp/libs/opentype.js"></script>
    <script src="webapp/libs/extractedRaphael.js"></script>
    <script src="webapp/libs/require.js"></script>
    <script src="webapp/libs/handlebars-v1.3.0.js"></script>
    <script src="webapp/libs/ember-1.5.0-beta5.pre7.js"></script>
    <script src="webapp/libs/ember-data-1.0.0-beta7.js"></script>

    <script>
        requirejs.config({
            baseUrl: 'webapp'
        });
    </script>

    <link rel="stylesheet" href="webapp/twoDView.css" type="text/css">
    <style>
        * {
            -webkit-box-sizing: border-box;
            -moz-box-sizing: border-box;
            box-sizing: border-box;
        }

        body {
            display: flex;
            display: -webkit-box;
            display: -webkit-flex;
            display: -ms-flexbox;
        }

        html, body {
            height: 100%;
            padding: 0;
            margin: 0;
        }

        #drawing, #code {
            display: block;
            flex: 1;
            -webkit-flex: 1;
            align-items: center;
            border: solid;
            padding: 0;
            margin: 0;
        }

    </style>
</head>
<body>
<script type="text/x-handlebars" data-template-name="text">
    <label for="text">Text:</label><br>
    {{input type="text" id="text" valueBinding="text" title="your text" action="launchComputationImmediately"}}
    <br>
    <label for="toolDiameter" title="in mm">Tool Diameter:</label><br>
    {{view TextApplication.NumberField id="toolDiameter" placeholder="toolDiameter"
    numericValueBinding="toolDiameter" min="0" action="launchComputationImmediately"}}
    <br>
    <label for="radialEngagement" title="ratio [0-1]">Radial Engagement:</label><br>
    {{view TextApplication.NumberField id="radialEngagement" placeholder="radialEngagement"
    numericValueBinding="radialEngagementRatio" min="0" max="1" step="0.05" action="launchComputationImmediately"}}
    <br>
</script>
<div id="drawing"></div>
<textarea id="code"></textarea>
<script>
    var drawing = $('#drawing');
    require(['cnc/twoDView', 'cnc/cam', 'samples/fontExample.js', 'cnc/text', 'cnc/pocket', 'cnc/ui/views', 'libs/simplify'], function (twoD, cam, fontExample, text, pocket, views, simplify) {
        window.TextApplication = Ember.Application.create({
            LOG_TRANSITIONS: true
        });
        TextApplication.Router.reopen({
            rootURL: '/webgcode/'
        });
        TextApplication.Router.map(function () {
            this.resource('text', {path: '/'});
        });
        //TODO: find how to inject this into the template scope directly
        TextApplication.NumberField = views.NumberField;
        TextApplication.TextController = Ember.ObjectController.extend({
            init: function () {
                this._super();
                var textGroup = twoDView.paper.group();
                this.set('textGroup', textGroup);
                var pocketGroup = twoDView.paper.group();
                this.set('pocketGroup', pocketGroup);
                this.display = {
                    displayClipperComputingPoly: function (clipperPoly) {
                        var res1 = pocketGroup.path(null).attr({class: 'computingPolygon', 'vector-effect': 'non-scaling-stroke', fill: 'url(#computingFill)'});
                        machine.fromClipper(simplifyPolys(clipperPoly)).map(function (poly) {
                            if (poly.path.length > 1)
                                cam.pushOnPath(res1, poly);
                            res1.node.pathSegList.appendItem(res1.node.createSVGPathSegClosePath());
                        });
                        return res1;
                    }.bind(this),
                    displayUndercutPoly: function (clipperPoly) {
                        var res1 = pocketGroup.path(null).attr({class: 'undercutPolygon', 'vector-effect': 'non-scaling-stroke'});
                        machine.fromClipper(clipperPoly).map(function (poly) {
                            if (poly.path.length > 1)
                                cam.pushOnPath(res1, poly);
                            res1.node.pathSegList.appendItem(res1.node.createSVGPathSegClosePath());
                        });
                        return res1;
                    }.bind(this)
                }
            },
            toolDiameter: 2,
            radialEngagementRatio: 0.9,
            actions: {
                launchComputationImmediately: function () {
                    this.computePocket();
                    Ember.run.debounce(this, this.computePocket, 2000);
                }
            },
            toolChanged: function () {
                Ember.run.debounce(this, this.computePocket, 2000);
            }.observes('toolDiameter', 'radialEngagementRatio').on('init'),
            textChanged: function () {
                var t = this.get('text');
                if (t == null)
                    return;
                var self = this;
                var svgElement = self.get('textGroup');
                self.abortComputation();
                svgElement.clear();
                this.get('pocketGroup').clear();
                text.getText('Seymour One', t, 30).then(function (textOutline) {
                    Ember.run(function () {
                        var textContour = svgElement.path(textOutline).attr({stroke: 'gray', 'vector-effect': 'non-scaling-stroke', fill: 'none'});
                        twoDView.zoomExtent();
                        self.set('textContour', textContour);
                        Ember.run.debounce(self, self.computePocket, 2000);
                    });
                }).catch(function (error) {
                            console.error(error.stack);
                        });
            }.observes('text').on('init'),
            computePocket: function () {
                var self = this;
                var svgElement = this.get('pocketGroup');
                var toolRadius = this.get('toolDiameter') / 2;
                var radialEngagementRatio = this.get('radialEngagementRatio');
                var passedTextContour = this.get('textContour');
                var text = this.get('text');
                this.abortComputation();
                var poly2 = machine.toClipper(passedTextContour);
                svgElement.clear();
                function registerPocket(pocketToolPaths) {

                    function displayClipper(clipperPoly, attr) {
                        var res1 = svgElement.path(null).attr({'vector-effect': 'non-scaling-stroke'}).attr(attr);
                        machine.fromClipper(clipperPoly).map(function (poly) {
                            if (poly.path.length > 1)
                                cam.pushOnPath(res1, poly);
                        });
                    }

                    function registerPocket(pocket) {
                        for (var j = 0; j < pocket.children.length; j++)
                            registerPocket(pocket.children[j]);
                        if (pocket.spiraledToolPath) {
                            displayClipper(simplifyPolys([pocket.spiraledToolPath.path]), {stroke: 'blue', fill: 'none'});
                            displayClipper(simplifyPolys(pocket.spiraledToolPath.shell), {stroke: 'none', fill: 'rgba(100, 100, 255, 0.2)',
                                'fill-rule': 'evenodd', title: 'spiral toolpath'});
                        } else
                            displayClipper(simplifyPolys(pocket.contour), {stroke: 'blue', fill: 'none'});
                    }

                    for (var i = 0; i < pocketToolPaths.length; i++)
                        for (var j = 0; j < pocketToolPaths[i].length; j++)
                            registerPocket(pocketToolPaths[i][j]);
                }

                var promise = pocket.createPocket(poly2, toolRadius * machine.clipperScale, radialEngagementRatio, self.display);
                self.set('computationPromise', promise);
                promise.then(function (pocketToolPaths) {
                    if (text == self.get('text'))
                        Ember.run(null, registerPocket, pocketToolPaths);
                },function (error) {
                    console.log(error.stack);
                }).finally(function () {
                            self.set('computationPromise', null);
                        });
            },
            abortComputation: function () {
                var promise = this.get('computationPromise');
                if (promise == null)
                    return;
                promise.abort();
                this.set('computationPromise', null);
            }
        });
        TextApplication.TextRoute = Ember.Route.extend({
            model: function () {
                return this.store.find('text', 1);
            }
        });
        TextApplication.ApplicationAdapter = DS.FixtureAdapter.extend();
        TextApplication.Text = DS.Model.extend({
            text: DS.attr('string')
        });
        TextApplication.Text.FIXTURES = [
            {
                id: 1,
                text: 'text1'
            },
            {
                id: 2,
                text: 'long text'
            }
        ];
        function simplifyPolys(polys) {
            return polys.map(function (poly) {
                var simplified = simplify(poly, machine.clipperScale / 100, true);
                console.log('simplified', poly.length, simplified.length);
                return simplified;
            });
        }

        var twoDView = new twoD.TwoDView(drawing);
        var machine = new cam.Machine(twoDView.paper);
    })
</script>
</body>
</html>
