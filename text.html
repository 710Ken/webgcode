<!doctype html>
<html>
<head>
    <meta http-equiv="X-UA-Compatible" content="chrome=1"/>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>CNC Text Tool</title>
    <script src="webapp/libs/jquery.min.js"></script>
    <script src="webapp/libs/svg.js"></script>
    <script src="webapp/libs/jquery.mousewheel.js"></script>
    <script src="webapp/libs/opentype.js"></script>
    <script src="webapp/libs/extractedRaphael.js"></script>
    <script src="webapp/libs/require.js"></script>
    <script src="webapp/libs/handlebars-v1.3.0.js"></script>
    <script src="webapp/libs/ember-1.5.0-beta5.pre7.js"></script>
    <script src="webapp/libs/ember-data-1.0.0-beta7.js"></script>

    <script>
        requirejs.config({
            baseUrl: 'webapp'
        });
    </script>

    <link rel="stylesheet" href="webapp/twoDView.css" type="text/css">
    <style>
        * {
            -webkit-box-sizing: border-box;
            -moz-box-sizing: border-box;
            box-sizing: border-box;
        }

        body {
            display: flex;
            display: -webkit-box;
            display: -webkit-flex;
            display: -ms-flexbox;
        }

        html, body {
            height: 100%;
            padding: 0;
            margin: 0;
        }

        #drawing, #code {
            display: flex;
            display: -webkit-flex;
            align-items: stretch;
            flex: 1;
            -webkit-flex: 1;
            border: solid;
            padding: 0;
            margin: 0;
        }

        #code {
            flex: 0.5;
        }

        .emberPart {
            align-items: stretch;
            display: flex;
            display: -webkit-flex;
            align-items: stretch;
            padding: 0;
            margin: 0;
            flex: 1;
            -webkit-flex: 1;
        }

        .controls {
            flex: 0 0 auto;
            -webkit-flex: 0 0 auto;

            align-items: stretch;
        }

    </style>
</head>
<body>

<script type="text/x-handlebars" data-template-name="text">
    <div class="controls">
        <label for="text">Text:</label><br>
        {{input type="text" id="text" valueBinding="text" title="your text"}}
        <br>
        <label for="toolDiameter" title="in mm">Tool Diameter:</label><br>
        {{view TextApplication.NumberField id="toolDiameter" placeholder="tool diameter"
        numericValueBinding="toolDiameter" min="0" action="launchComputationImmediately"}}
        <br>
        <label for="radialEngagement" title="ratio ]0-1]">Radial Engagement:</label><br>
        {{view TextApplication.NumberField id="radialEngagement" placeholder="radial engagement"
        numericValueBinding="radialEngagementRatio" min="0" max="1" step="0.05" action="launchComputationImmediately"}}
        <br>
        <label for="depth" title="in mm">Depth:</label><br>
        {{view TextApplication.NumberField id="depth" placeholder="depth"
        numericValueBinding="depth" min="0" max="1" step="0.05" action="launchComputationImmediately"}}
        <br>

    </div>
    <div id="drawing">
        {{view TextApplication.TwoDView}}
    </div>
    <textarea id="code"></textarea>

</script>

<script>
    var drawing = $('#drawing');
    require(['cnc/ui/emberTwoDView', 'cnc/cam', 'samples/fontExample.js', 'cnc/text', 'cnc/pocket', 'cnc/ui/views', 'libs/simplify'], function (emberTwoDView, cam, fontExample, text, pocket, views, simplify) {
        window.TextApplication = Ember.Application.create({
            customEvents: {
                mousewheel: "mousewheel"
            }
        });
        TextApplication.Router.reopen({
            rootURL: '/webgcode/'
        });
        TextApplication.Router.map(function () {
            this.resource('text', {path: '/'});
        });
        //TODO: find how to inject this into the template scope directly
        TextApplication.NumberField = views.NumberField;

        function toggleClass(svgElement, className, toggle) {
            var classAttr = svgElement.attr('class');
            var classes = classAttr.split(' ');
            var index = classes.indexOf(className);
            if (toggle) {
                if (index == -1)
                    svgElement.attr('class', classAttr + ' ' + className);
            } else if (index != -1) {
                classes.splice(index, 1);
                svgElement.attr('class', classes.join(' '));
            }
        }

        TextApplication.TwoDView = Ember.View.extend({
            classNames: ['TwoDView'],
            init: function () {
                this._super();
                //http://emberjs.com/guides/object-model/observers/#toc_unconsumed-computed-properties-do-not-trigger-observers
                this.get('controller');
                var undercuts = [];
                this.set('undercuts', undercuts);
                var _this = this;
                this.get('controller.undercut').addArrayObserver({
                    arrayWillChange: function (observedObj, start, removeCount, addCount) {
                        for (var i = 0; i < removeCount; i++)
                            undercuts[start + i].remove();
                        undercuts.splice(start, removeCount);
                    },
                    arrayDidChange: function (observedObj, start, removeCount, addCount) {
                        var pocketGroup = _this.get('pocketGroup');
                        var add = [];
                        for (var i = 0; i < addCount; i++)
                            add.push(_this.displayClipper(pocketGroup, _this.simplify(observedObj[start + i]), {class: 'undercut'}));
                        Array.prototype.splice.apply(undercuts, [start, 0].concat(add));
                    }
                });
            },
            simplify: function (poly) {
                return cam.simplifyPolygons(poly, machine.clipperScale / 100);
            },
            didInsertElement: function () {
                var view = emberTwoDView.EmberTwoDView.create({element: this.$()});
                this.set('nativeComponent', view);
                var outline = view.paper.path('M0,0').attr({class: 'outline', fill: 'url(#computingFill)'});
                outline.remove();
                this.set('outline', outline);
                this.set('pocketGroup', view.paper.group());

            },
            clear: function () {
                this.get('pocketGroup').clear();
            },
            synchronizeOutline: function () {
                this.clear();
                var d = this.get('controller.textOutline');
                var paper = this.get('nativeComponent.paper');
                if (d != null) {
                    paper.add(this.get('outline').attr({d: d}));
                    this.synchronizeComputing();
                    Ember.run.scheduleOnce('afterRender', this.get('nativeComponent'), 'zoomExtent');
                } else
                    this.get('outline').remove();
            }.observes('controller.textOutline'),
            synchronizeComputing: function () {
                var computing = this.get('controller.computing');
                if (computing)
                    this.clear();
                toggleClass(this.get('outline'), 'computing', computing);
            }.observes('controller.computing'),
            synchronizePocket: function () {
                var paper = this.get('nativeComponent.paper');
                var pocketGroup = this.get('pocketGroup');
                var _this = this;

                function displayPocket(pocket) {
                    for (var j = 0; j < pocket.children.length; j++)
                        displayPocket(pocket.children[j]);
                    if (pocket.spiraledToolPath) {
                        _this.displayClipper(pocketGroup, _this.simplify([pocket.spiraledToolPath.path]), {class: 'pocket'});
                        _this.displayClipper(pocketGroup, _this.simplify(pocket.spiraledToolPath.shell), {class: 'spiralPocketOutline',
                            title: 'spiral toolpath'});
                    } else
                        _this.displayClipper(pocketGroup, _this.simplify(pocket.contour), {class: 'pocket'});
                }

                var pocketToolPaths = this.get('controller.pocketToolPaths');
                for (var i = 0; i < pocketToolPaths.length; i++)
                    for (var j = 0; j < pocketToolPaths[i].length; j++)
                        displayPocket(pocketToolPaths[i][j]);

            }.observes('controller.pocketToolPaths'),
            displayClipper: function (parent, clipperPoly, attr) {
                var d = '';
                machine.fromClipper(clipperPoly).map(function (poly) {
                    var firstPoint = poly.getStartPoint();
                    d += ' M ' + firstPoint.x + ',' + firstPoint.y;
                    poly.forEachPoint(function (x, y) {
                        d += ' L ' + x + ',' + y;
                    }, null);
                });
                return parent.path(d).attr(attr);
            }
        });

        TextApplication.TextView = Ember.View.extend({
            classNames: ['emberPart'],
            templateName: 'text'
        });
        TextApplication.TextController = Ember.ObjectController.extend({
            actions: {
                launchComputationImmediately: function () {
                    this.computePocket();
                }
            },
            undercut: [],
            textChanged: function () {
                this.abortComputation();
                var t = this.get('text');
                if (t == null)
                    return;
                var _this = this;
                text.getText('Seymour One', t, 30).then(function (textOutline) {
                    _this.set('textOutline', textOutline);
                    _this.computePocket();
                }).catch(function (error) {
                            console.error(error.stack);
                        });
            }.observes('text').on('init'),
            computing: Ember.computed.bool('computationPromise'),
            computePocket: function () {
                var _this = this;
                var toolRadius = this.get('toolDiameter') / 2 * machine.clipperScale;
                var textOutline = this.get('textOutline');
                _this.get('undercut').clear();
                this.abortComputation();
                console.time('computation');
                var poly2 = machine.pathDefToClipper(textOutline);
                var display = {
                    displayUndercutPoly: function (poly) {
                        _this.get('undercut').pushObject(poly);
                    }};
                var promise = pocket.createPocket(poly2, toolRadius, this.get('radialEngagementRatio'), display, false);
                _this.set('computationPromise', promise);
                promise.then(function (pocketToolPaths) {
                    _this.set('pocketToolPaths', pocketToolPaths);
                },function (error) {
                    console.log(error.stack);
                }).finally(function () {
                            console.timeEnd('computation');
                            _this.set('computationPromise', null);
                        });
            },
            abortComputation: function () {
                var promise = this.get('computationPromise');
                if (promise == null)
                    return;
                promise.abort();
                this.set('computationPromise', null);
            }
        });

        TextApplication.TextRoute = Ember.Route.extend({
            model: function () {
                return {
                    id: 1,
                    text: '.',
                    toolDiameter: 2,
                    radialEngagementRatio: 0.9,
                    depth: 1
                }
            },
            controllerName: 'text'
        });
        TextApplication.ApplicationAdapter = DS.FixtureAdapter.extend();
        var machine = new cam.Machine(null);
    })
</script>
</body>
</html>

