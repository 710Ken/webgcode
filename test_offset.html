<!doctype html>
<html>
<head>
    <title>Contouring Test</title>
    <script src="webapp/libs/jquery.min.js"></script>
    <script src="webapp/libs/handlebars-1.0.0-rc.4.js"></script>
    <script src="webapp/libs/ember-1.0.0-rc.5.js"></script>
    <script src="webapp/libs/ember-data-0.13.min.js"></script>
    <script src="webapp/libs/Three.js"></script>
    <script src="webapp/libs/TrackballControls.js"></script>
    <script src="webapp/libs/csg.js"></script>
    <script src="webapp/libs/ThreeCSG.js"></script>
    <script src="webapp/libs/svg.js"></script>
    <script src="webapp/libs/svg.draggable.js"></script>
    <script src="webapp/libs/svg.memory.js"></script>
    <script src="webapp/libs/jquery.mousewheel.js"></script>
    <script src="webapp/libs/clipper_unminified.js"></script>
    <script src="webapp/cnc/elliptic.js"></script>
    <script src="webapp/cnc/morphology.js"></script>

    <style>
        * {
            -webkit-box-sizing: border-box;
            -moz-box-sizing: border-box;
            box-sizing: border-box;
        }

        th {
            text-align: right;
        }

        .threeDView {
            width: 50%;
            height: 400px;
            float: right;
            border: solid
        }
    </style>
</head>
<body>
<div id="drawing" style="border:solid; width:600px; height: 700px; float:left;overflow: hidden">
</div>
<textarea id='code' style="border:solid; width:600px; height: 700px; float:right;"></textarea>
<script>

</script>
<script>
    function hyp(x, y) {
        return Math.sqrt(x * x + y * y);
    }
    var svg = SVG($('#drawing')[0]).size(600, 700);
    var paper = svg.group().attr({id: 'root', 'vector-effect': 'non-scaling-stroke'});
    function setMatrix(element, matrix) {
        var components = $.map('abcdef'.split(''),function (c) {
            return matrix[c];
        }).join(',');
        element.attr({transform: 'matrix(' + components + ')'});
    }
    $('#drawing').mousewheel(function (event, delta, deltaX, deltaY) {
        var svgRoot = paper.node;
        var p = svg.node.createSVGPoint();
        p.x = event.clientX;
        p.y = event.clientY;
        p = p.matrixTransform(svgRoot.getCTM().inverse());
        var k = svg.node.createSVGMatrix().translate(p.x, p.y).scale(1 + delta / 360).translate(-p.x, -p.y);
        var m = svgRoot.getCTM().multiply(k);
        setMatrix(paper, m);
        event.preventDefault();
    });
    var pointCount = 500;
    var scale = 10000;

    function showPolygon(path, points, getX, getY) {
        $.each(points, function (index, point) {
            var segment;
            if (index == 0)
                segment = path.node.createSVGPathSegMovetoAbs(getX(point), getY(point));
            else
                segment = path.node.createSVGPathSegLinetoAbs(getX(point), getY(point));
            path.node.pathSegList.appendItem(segment);
        });
        path.node.pathSegList.appendItem(path.node.createSVGPathSegClosePath());
    }

    function getX(p) {
        return p.X / scale;
    }
    function getY(p) {
        return p.Y / scale;
    }
    function showClipperPolygon(group, polygon, stroke) {
        $.each(polygon, function (_, polygon) {
            var path = group.path('', true).attr({'vector-effect': 'non-scaling-stroke', fill: 'none', stroke: stroke == null ? 'red' : stroke});
            showPolygon(path, polygon, getX, getY);
        });
    }

    var isStraightLine = function () {
        var STRAIGHT_LINES = ['PATHSEG_CLOSEPATH', 'PATHSEG_LINETO_ABS', 'PATHSEG_LINETO_REL',
            'PATHSEG_LINETO_HORIZONTAL_ABS', 'PATHSEG_LINETO_HORIZONTAL_REL', 'PATHSEG_LINETO_VERTICAL_ABS',
            'PATHSEG_LINETO_VERTICAL_REL'];
        var linePrefixes = [];
        $.each(STRAIGHT_LINES, function (_, type) {
            linePrefixes[SVGPathSeg[type]] = true;
        });
        return function isStraightLine(pathSeg) {
            return !!linePrefixes[pathSeg.pathSegType];
        };
    }();

    function getPathLengths(path) {
        var shadowPath = paper.defs().path();
        var segmentsLengths = [];
        var clone = path.clone();
        shadowPath.node.pathSegList.clear();
        for (var i = 0; i < path.node.pathSegList.numberOfItems; i++) {
            //explicitly remove it because append() in chrome removes it while ff leaves it
            var item = clone.node.pathSegList.removeItem(0);
            shadowPath.node.pathSegList.appendItem(item);
            segmentsLengths[i] = shadowPath.node.getTotalLength();
        }
        shadowPath.remove();
        return segmentsLengths;
    }

    function contouring(shapePath, toolRadius, translation) {
        if (translation == null)
            translation = {x: 0, y: 0};
        var totalLength = shapePath.node.getTotalLength();
        var index = 0;
        var clipperPoints = [];
        var segmentsLengths = getPathLengths(shapePath);

        for (var l = 0; l <= totalLength;) {
            index++;
            var segmentIndex = shapePath.node.getPathSegAtLength(l);
            var pathSeg = shapePath.node.pathSegList.getItem(segmentIndex);
            var p = shapePath.node.getPointAtLength(l);

            if (isStraightLine(pathSeg)) {
                //push the initial segment point
                p = shapePath.node.getPointAtLength(segmentsLengths[segmentIndex - 1]);
                //skip to slightly after the end of the segment
                l = segmentsLengths[segmentIndex] + totalLength / pointCount * 0.01;
            } else
                l += totalLength / pointCount;
            clipperPoints.push({X: (translation.x + p.x) * scale, Y: (translation.y + p.y) * scale});
        }
        clipperPoints = [clipperPoints];
        clipperPoints = ClipperLib.Clean(clipperPoints, 0.0001 * scale);
        var cpr = new ClipperLib.Clipper();
        return cpr.OffsetPolygons(clipperPoints, toolRadius * scale, ClipperLib.JoinType.jtRound, 0.25, true);
    }

    function createCircle(centerX, centerY, radius) {
        function coords(x, y) {
            return x + ', ' + y;
        }

        function arc(dx, dy) {
            return 'A' + coords(radius, radius) + ' 0 0 0 ' + coords(centerX + dx * radius, centerY + dy * radius);
        }

        //avoid long arcs because webkit makes huge errors with them in getPointAtLength()
        var arcs = [arc(1, 0), arc(0, -1), arc(-1, 0), arc(0, 1)];
        return 'M' + coords(centerX, centerY + radius) + ' ' + arcs.join(' ');
    }

    var toolDiameter = 3;
    var toolRadius = toolDiameter / 2;

    function createDrillHole(x, y) {
        return [
            [
                {X: x * scale, Y: y * scale}
            ]
        ];
    }

    function drillCorners(path) {
        var holes = [];
        $.each(getPathLengths(path), function (i, l) {
            if (path.node.pathSegList.getItem(i).pathSegType != SVGPathSeg.PATHSEG_CLOSEPATH) {
                var point = path.node.getPointAtLength(l);
                holes.push(createDrillHole(point.x, point.y));
            }
        });
        return holes;
    }

    var plugHole = paper.path('M40,25l0,15.5l-15.5,0l0,-15.5z', true).attr({'vector-effect': 'non-scaling-stroke', fill: 'none', stroke: 'red'});
    var cornerHoles = drillCorners(plugHole);

    var plugHoleToolPath = contouring(plugHole, -toolRadius);
    showClipperPolygon(paper, plugHoleToolPath, 'blue');

    var circle = paper.path(createCircle(47 + 65.5 / 2, 40, 65.5 / 2), true).attr({'vector-effect': 'non-scaling-stroke', fill: 'none', stroke: 'red'});
    var circleToolPath = contouring(circle, -toolRadius);
    showClipperPolygon(paper, circleToolPath, 'blue');

    var rectangle = paper.path('M0,0L120,0L120,80L0,80Z', true).attr({'vector-effect': 'non-scaling-stroke', fill: 'none', stroke: 'red'});
    var rectangleToolPath = contouring(rectangle, toolRadius);
    showClipperPolygon(paper, rectangleToolPath, 'blue');


    var box = paper.bbox();
    var m = paper.node.getCTM();
    var newScale = Math.min(svg.node.width.baseVal.value / box.width, svg.node.height.baseVal.value / box.height) * 0.9;
    m.a = newScale;
    m.d = -newScale;
    m.e = -box.x + box.width * 0.25;
    m.f = -(-box.y + box.height * 0.5 - svg.node.height.baseVal.value);
    setMatrix(paper, m);
    var travelZ = 10;
    var workZ = -5;
    var ops = cornerHoles.concat([plugHoleToolPath, circleToolPath, rectangleToolPath]);
    function pos(x, y, z) {
        return 'X' + x + ' Y' + y + ' Z' + z;
    }
    var output = '';
    function appendLine(l) {
        output += l + '\n';
    }
    $.each(ops, function (_, operation) {
        $.each(operation, function (_, polygon) {
            appendLine('G0 ' + pos(getX(polygon[0]), getY(polygon[0]), travelZ));
            appendLine('G1 ' + pos(getX(polygon[0]), getY(polygon[0]), workZ));
            $.each(polygon, function (_, point) {
                appendLine('G1 ' + pos(getX(point), getY(point), workZ));
            });
            //close the loop
            appendLine('G1 ' + pos(getX(polygon[0]), getY(polygon[0]), workZ));
            appendLine('G1 ' + pos(getX(polygon[0]), getY(polygon[0]), travelZ));
        });
    });
    $('#code').text(output);
</script>
</body>
</html>
