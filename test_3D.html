<!DOCTYPE html >
<html>
<head>
<meta http-equiv="X-UA-Compatible" content="chrome=1"/>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<title>Visual CAM</title>
<script src="webapp/libs/require.js"></script>
<script src="webapp/config.js"></script>
<script>
    requirejs.config({
        baseUrl: 'webapp'
    });
</script>
<link rel="shortcut icon" href="webapp/images/icon_fraise_48.png"/>
<link rel="stylesheet" href="webapp/twoDView.css" type="text/css">
<link rel="stylesheet" href="webapp/threeDView.css" type="text/css">
<link rel="stylesheet" href="webapp/libs/bootstrap/css/bootstrap.min.css">
<link rel="stylesheet" href="webapp/libs/font-awesome-4.2.0/css/font-awesome.min.css">
<style>

    body, html {
        height: 100%;
        width: 100%;
        margin: 0;
        padding: 0;
        background: #fafafa;
        color: #444;
    }

    body {
        font-family: sans-serif;
        display: flex;
        flex-direction: column;
    }

    canvas {
        flex: 1;
    }

    .moving {
        cursor: move;
    }
</style>
<script>
require(['jQuery', 'THREE', 'cnc/cam/toolProfile', 'cnc/cam/modelProjector', 'libs/threejs/STLLoader', 'libs/threejs/postprocessing/EffectComposer',
            'libs/threejs/postprocessing/RenderPass', 'libs/threejs/postprocessing/ShaderPass',
            'libs/threejs/OrbitControls', 'libs/threejs/postprocessing/CopyShader'],
        function ($, THREE, toolProfile, ModelStage, STLLoader, EffectComposer, RenderPass, ShaderPass, OrbitControls, CopyShader) {
            var pixelsOnRadius = 10;
            var $container = $('body');
            var renderer = new THREE.WebGLRenderer({antialias: false, alpha: true, precision: 'highp', autoClear: true});
            renderer.autoClear = true;
            $container.append(renderer.domElement);
            var outputWidth = $container.width();
            var outputHeight = $container.height();
            renderer.sortObjects = false;
            renderer.setSize(outputWidth, outputHeight);
            renderer.setViewport(0, 0, outputWidth, outputHeight);
            renderer.clear();
            new STLLoader().load('webapp/samples/soap.stl', function (geometry) {
                function draw() {
                    displayGeometry(geometry);
                }

                draw();
            });

            function TerrainStage(geometry) {
                function divV(v1, v2) {
                    return v1.set(v1.x / v2.x, v1.y / v2.y);
                }

                this.modelStage = new ModelStage();
                this.modelStage.setGeometry(geometry);

                var bboxSize = this.modelStage.modelBbox.size();
                var modelDisplaySideMm = (bboxSize.x > bboxSize.y ? bboxSize.x : bboxSize.y) * 1.1;
                var bufferOrigin = new THREE.Vector2(0, 0).addScalar(-modelDisplaySideMm / 2);
                var bufferSize = new THREE.Vector2(modelDisplaySideMm, modelDisplaySideMm);
                this.modelStage.camera.left = bufferOrigin.x;
                this.modelStage.camera.right = bufferOrigin.x + bufferSize.x;
                this.modelStage.camera.bottom = bufferOrigin.y;
                this.modelStage.camera.top = bufferOrigin.y + bufferSize.y;
                this.modelStage.camera.updateProjectionMatrix();

                var toolRadiusMm = 2;
                var toolTexture = new THREE.DataTexture(new Float32Array(pixelsOnRadius), pixelsOnRadius, 1, THREE.LuminanceFormat, THREE.FloatType);
                var bufferOffset = new THREE.Vector2(0, 0);
                this.bufferOrigin = bufferOrigin.clone().add(bufferOffset);
                this.bufferSize = bufferSize.clone().multiply(new THREE.Vector2(1, 1));
                var terrainRatio = divV(this.bufferSize.clone(), bufferSize);
                var terrainTranslation = this.bufferOrigin.clone().sub(bufferOrigin).divide(bufferSize);
                this.minkowskiPass = new ShaderPass({
                    uniforms: {
                        tDiffuse: {type: 't'},
                        toolProfile: {type: 't', value: toolTexture},
                        toolToPartRatio: {type: 'f', value: toolRadiusMm / this.modelStage.displaySideMm},
                        terrainRatio: {type: 'v2', value: terrainRatio},
                        terrainTranslation: {type: 'v2', value: terrainTranslation},
                        minZ: {type: 'f', value: -Infinity}
                    },
                    defines: {
                        radialSamples: null
                    },
                    vertexShader: [
                        'varying vec2 vUv;',
                        'void main() {',
                        '   vUv = uv;',
                        '   gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);',
                        '}'
                    ].join('\n'),
                    fragmentShader: [
                        'uniform sampler2D tDiffuse;',
                        'uniform sampler2D toolProfile;',
                        'uniform float toolToPartRatio;',
                        'uniform vec2 terrainRatio;',
                        'uniform vec2 terrainTranslation;',
                        'uniform float minZ;',
                        'varying vec2 vUv;',
                        'highp float factor = (exp2(24.0) - 1.0) / exp2(24.0);',
                        'vec3 EncodeFloatRGB(highp float v) {',
                        '   vec3 enc = fract(vec3(1.0, 255.0, 255.0 * 255.0) * factor * v);',
                        '   enc -= enc.yzz * vec3(1.0 / 255.0, 1.0 / 255.0, 0.0);',
                        '   return enc;',
                        '}',
                        'highp float DecodeFloatRGB(vec3 rgb) {',
                        '   return dot(rgb, vec3(1.0, 1.0 / 255.0, 1.0 / 255.0 / 255.0)) / factor;',
                        '}',
                        'highp float readHeight(vec2 pos) {',
                        '   highp vec4 color = texture2D(tDiffuse, terrainRatio * vUv + terrainTranslation + pos * toolToPartRatio);',
                        '   highp float displacement = texture2D(toolProfile, vec2(0.5 / float(radialSamples) + length(pos) / float(radialSamples) * float(radialSamples - 1), 0.5)).r;',
                        '   return DecodeFloatRGB(color.rgb) - displacement;',
                        '}',
                        'void main() {',
                        '   highp int radiusSquared = radialSamples * radialSamples;',
                        '   highp float sum = readHeight(vec2(0.0, 0.0));',
                        '   for (int i = -radialSamples; i <= radialSamples; i++)',
                        '       for (int j = -radialSamples; j <= radialSamples; j++)',
                        '           if (i * i + j * j <= radiusSquared)',
                        '               sum = max(sum, readHeight(vec2(i, j) / float(radialSamples)));',
                        '   gl_FragColor = vec4(EncodeFloatRGB(max(minZ, sum)), 1.0);',
                        '}'].join('\n')
                });
                this.copy = new ShaderPass(CopyShader);
                this.copy.renderToScreen = true;
                this.toolRadiusMm = toolRadiusMm;
                this.toolType = 'ball';
                this.renderer = renderer;
                this.toolLeaveStockRadius = 0.5;
                this.updateToolShape();
            }

            TerrainStage.prototype = {
                render: function (renderer) {
                    if (!this.modelStageClean) {
                        this.modelStage.render(renderer, this.modelBuffer);
                        this.modelStageClean = true;
                        this.minkowskiPassClean = false;
                    }
                    if (!this.minkowskiPassClean) {
                        this.minkowskiPass.render(renderer, this.toolPosBuffer, this.modelBuffer);
                        this.minkowskiPassClean = true;
                    }
                },
                setSampleRate: function (newSampleRate) {
                    console.log('sampleRate', newSampleRate);
                    if (this.modelBuffer)
                        this.modelBuffer.dispose();
                    var bboxSize = this.modelStage.modelBbox.size();
                    var displaySide = (this.modelStage.aspectRatio >= 1 ? bboxSize.x : bboxSize.y) * newSampleRate;
                    this.modelBuffer = new THREE.WebGLRenderTarget(displaySide, displaySide,
                            {minFilter: THREE.NearestFilter, magFilter: THREE.NearestFilter, type: THREE.FloatType});
                },
                updateToolShape: function () {
                    var totalPixels = 40000000;
                    var ySamples = 10;
                    var ds = this.modelStage.displaySideMm;
                    var s = this.toolRadiusMm + this.toolLeaveStockRadius;
                    var y = ySamples;
                    var z = totalPixels;
                    var pw = Math.pow;

                    function crt(x) {
                        return pw(x, 1 / 3);
                    }

                    //http://www.wolframalpha.com/input/?i=solve+4*r%5E2*y*d*r%2Fs%2Bd%5E2*r%5E2%2Fs%5E2+%3D+z+for+r
                    var bigSquareRoot = Math.sqrt(108 * pw(ds, 4) * pw(s, 8) * pw(y, 4) * pw(z, 2) - pw(ds, 8) * pw(s, 4) * pw(y, 2) * z);
                    var bigCubicRoot = crt(-pw(ds, 6) + 216 * pw(ds, 2) * pw(s, 4) * pw(y, 2) * z + 12 * Math.sqrt(3) * bigSquareRoot);
                    var estimatePixels = (bigCubicRoot / (ds * s * y) + pw(ds, 3) / ((s * y * bigCubicRoot)) - ds / (s * y)) / 12;
                    var newPixelsOnRadius = isNaN(estimatePixels) ? 1 : Math.floor(estimatePixels) + 1;
                    console.log('s', s, 'radialSamples', newPixelsOnRadius);
                    console.log('estimated pixel count (millions): ', 4 * pw(newPixelsOnRadius, 2) * ySamples * ds * (newPixelsOnRadius / s) / 1000000);
                    var pixelsOnRadius = newPixelsOnRadius;
                    this.setSampleRate(pixelsOnRadius / s);
                    var pixelCount = (pixelsOnRadius * 2) * (pixelsOnRadius * 2) * ySamples * this.modelStage.displaySide + this.modelStage.displaySide * this.modelStage.displaySide;
                    console.log('actual pixel count (millions): ', pixelCount / 1000000);
                    var types = {cylinder: toolProfile.createCylindricalTool, ball: toolProfile.createSphericalTool, v: toolProfile.createVTool};
                    var samples = types[this.toolType](pixelsOnRadius, this.modelStage.zRatio, this.toolRadiusMm, this.toolLeaveStockRadius);
                    this.minkowskiPass.material.uniforms.toolProfile.value.image.data = new Float32Array(samples);
                    this.minkowskiPass.material.uniforms.toolProfile.value.image.width = pixelsOnRadius;
                    this.minkowskiPass.material.uniforms.toolProfile.value.needsUpdate = true;
                    this.minkowskiPass.material.defines.radialSamples = pixelsOnRadius;
                    this.minkowskiPass.material.needsUpdate = true;
                    this.minkowskiPass.material.uniforms.toolToPartRatio.value = (s / this.modelStage.displaySideMm).toPrecision(10);
                    this.minkowskiPass.material.needsUpdate = true;
                    if (this.toolPosBuffer)
                        this.toolPosBuffer.dispose();
                    this.toolPosBuffer = new THREE.WebGLRenderTarget(this.modelStage.displaySide, ySamples,
                            {minFilter: THREE.NearestFilter, magFilter: THREE.NearestFilter, type: THREE.FloatType});
                    this.modelStageClean = false;
                },
                setToolType: function (type) {
                    this.toolType = type;
                    this.updateToolShape();
                },
                setToolRadius: function (radius) {
                    this.toolRadiusMm = radius;
                    this.updateToolShape();
                },
                setLeaveStock: function (radius) {
                    this.toolLeaveStockRadius = radius;
                    this.updateToolShape();
                }
            };

            function displayGeometry(geometry) {
                var clonedGeometry = geometry.clone();
                var pipeline = new TerrainStage(geometry);
                var scene2 = new THREE.Scene();
                var camera2 = new THREE.PerspectiveCamera(45, outputWidth / outputHeight, 0.1, 1500);
                camera2.up.set(0, 0, 1);
                camera2.position.z = 100;
                scene2.add(camera2);
                camera2.updateMatrixWorld();
                var directionalLight = new THREE.DirectionalLight(0xffffff, 1);
                directionalLight.position.set(1000, 1000, 1000);
                scene2.add(directionalLight);
                var directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.5);
                directionalLight2.position.set(-1000, -1000, 1000);
                scene2.add(directionalLight2);
                var terrainToworldOffset = new THREE.Vector3(pipeline.bufferOrigin.x, pipeline.bufferOrigin.y, pipeline.modelStage.camera.position.z - pipeline.modelStage.camera.far);
                var terrainShader = {
                    wireframe: false,
                    size: 2,
                    uniforms: {
                        tDisplacement: {type: 't', value: null},
                        terrainToWorldRatio: {type: 'v3', value: new THREE.Vector3(pipeline.bufferSize.x, pipeline.bufferSize.y, 1 / pipeline.modelStage.zRatio)},
                        terrainToWorldOffset: {type: 'v3', value: terrainToworldOffset},
                        sampleCount: {type: 'v2', value: new THREE.Vector2(pipeline.toolPosBuffer.width, pipeline.toolPosBuffer.height)},
                        minZ: {type: 'f', value: -7}
                    },
                    vertexShader: [
                        'uniform sampler2D tDisplacement;',
                        'uniform vec3 terrainToWorldRatio;',
                        'uniform vec3 terrainToWorldOffset;',
                        'uniform vec2 sampleCount;',
                        'uniform float minZ;',
                        'varying vec4 color;',
                        'highp float factor = (exp2(24.0) - 1.0) / exp2(24.0);',
                        'highp float DecodeFloatRGB(vec3 rgb) {',
                        '   return dot(rgb, vec3(1.0, 1.0 / 255.0, 1.0 / 255.0 / 255.0)) / factor;',
                        '}',
                        'void main() {',
                        '   vec2 uv = position.xy / sampleCount * (sampleCount - 1.0) + 0.5 / sampleCount;',
                        '   color = texture2D(tDisplacement, vec2(uv));',
                        '   vec3 pos = vec3(uv, DecodeFloatRGB(color.rgb)) * terrainToWorldRatio + terrainToWorldOffset;',
                        '   pos.z = max(minZ, pos.z);',
                        '   gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);',
                        '}'
                    ].join('\n'),
                    fragmentShader: [
                        'varying vec4 color;',
                        'void main() {',
                        '   gl_FragColor = vec4(color.r, 0.6 - abs(color.r - 0.5), 1.0 - color.r, 1.0);',
                        '}'].join('\n')
                };

                var terrainMaterial = new THREE.ShaderMaterial(terrainShader);

                function createGrid(xRes, yRes, points, avoidX, avoidY) {
                    var geometry = new THREE.BufferGeometry();
                    var vertices = [];
                    var offset = 0;

                    function pushVertex(i, j) {
                        vertices.push(i / (xRes - 1), j / (yRes - 1), 0);
                    }

                    for (var i = 0; i < xRes; i++)
                        for (var j = 0; j < yRes; j++) {
                            if (points)
                                pushVertex(i, j);
                            else {
                                if (i != 0 && !avoidX) {
                                    pushVertex(i - 1, j);
                                    pushVertex(i, j);
                                }
                                if (j != 0 && !avoidY) {
                                    pushVertex(i, j - 1);
                                    pushVertex(i, j);
                                }
                            }
                            offset += 3
                        }
                    geometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(vertices), 3));
                    if (points)
                        return new THREE.PointCloud(geometry, terrainMaterial);
                    else
                        return new THREE.Line(geometry, terrainMaterial, THREE.LinePieces);
                }

                var grid = createGrid(pipeline.toolPosBuffer.width, pipeline.toolPosBuffer.height, false, false, true);
                grid.frustumCulled = false;
                scene2.add(grid);
                scene2.add(new THREE.Mesh(clonedGeometry, new THREE.MeshLambertMaterial({color: 0xFEEFFE, shading: THREE.SmoothShading})));

                document.documentElement.addEventListener('keydown', function (event) {
                    if (event.shiftKey === true) {
                        document.body.classList.add('moving');
                    }
                });

                document.documentElement.addEventListener('keyup', function (event) {
                    if (event.shiftKey === false) {
                        document.body.classList.remove('moving');
                    }
                });

                var controls = new OrbitControls(camera2, renderer.domElement);
                controls.rotateSpeed = 1.0;
                controls.zoomSpeed = 1.2;
                controls.panSpeed = 0.8;
                controls.noZoom = false;
                controls.noPan = false;
                controls.staticMoving = true;
                controls.dynamicDampingFactor = 0.3;
                controls.minDistance = 3;
                controls.keys = [ 65, 83, 68 ];
                controls.addEventListener('change', function () {
                    reRenderPipeline();
                });
                function reRender() {
                    terrainMaterial.uniforms.tDisplacement.value = pipeline.toolPosBuffer;
                    terrainMaterial.uniforms.sampleCount.value = new THREE.Vector2(pipeline.toolPosBuffer.width, pipeline.toolPosBuffer.height);
                    renderer.render(scene2, camera2);
                }

                function setToolType(type) {
                    console.time('tool change');
                    pipeline.setToolType(type);
                    reRenderPipeline();
                    console.timeEnd('tool change');
                }

                function setToolRadius(radius) {
                    $('#radius').text(radius);
                    console.time('tool change');
                    pipeline.setToolRadius(parseFloat(radius));
                    reRenderPipeline();
                    console.timeEnd('tool change');
                }

                function reRenderPipeline() {
                    console.time('complete render');
                    pipeline.render(renderer);
                    reRender();

                    //for pessimistic computation time measure, since gl.finish() is faked.
                    var gl = renderer.getContext();
                    gl.flush();
                    var pixelBuffer = new Uint8Array(4);
                    gl.readPixels(1, 1, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixelBuffer);
                    console.timeEnd('complete render');
                }

                window.setToolType = setToolType;
                window.setToolRadius = setToolRadius;
                window.setSliceZ = function (z) {
                    $('#slice').text(z);
                    console.time('tool change');
                    terrainMaterial.uniforms.minZ.value = parseFloat(z);
                    reRenderPipeline();
                    console.timeEnd('tool change');
                };
                window.setLeaveStock = function (radius) {
                    $('#leaveStock').text(radius);
                    console.time('tool change');
                    pipeline.setLeaveStock(parseFloat(radius));
                    reRenderPipeline();
                    console.timeEnd('tool change');
                };
                //pipeline.render(renderer);
                reRenderPipeline();
            }
        });
</script>
</head>
<body>
<div class="btn-toolbar" role="toolbar">
    <div class="btn-group" role="group">
        <label>shape: <select name="select" onChange="setToolType(this.value);">
            <option value="cylinder">Cylinder</option>
            <option value="ball" selected>Ball Nose</option>
            <option value="v">V Carving</option>
        </select></label>
        <label>Radius (
            <span id="radius">2</span>
            ): <input type="range" min="0.1" max="10" value="1" step="0.1"
                      oninput="setToolRadius(this.value)"></label>
        <label>Slice Z (
            <span id="slice">-7</span>
            ): <input type="range" min="-25" max="0" value="-7" step="0.5"
                      oninput="setSliceZ(this.value)"></label>
        <label>Leave stock (
            <span id="leaveStock">0.5</span>
            ): <input type="range" min="0" max="5" value="0.5" step="0.1"
                      oninput="setLeaveStock(this.value)"></label>
    </div>

</div>
</body>

</html>
