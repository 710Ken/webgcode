<!DOCTYPE html >
<html>
<head>
<meta http-equiv="X-UA-Compatible" content="chrome=1"/>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<title>Visual CAM</title>
<script src="webapp/libs/require.js"></script>
<script src="webapp/config.js"></script>
<script>
    requirejs.config({
        baseUrl: 'webapp'
    });
</script>
<link rel="shortcut icon" href="webapp/images/icon_fraise_48.png"/>
<link rel="stylesheet" href="webapp/twoDView.css" type="text/css">
<link rel="stylesheet" href="webapp/threeDView.css" type="text/css">
<link rel="stylesheet" href="webapp/libs/bootstrap/css/bootstrap.min.css">
<link rel="stylesheet" href="webapp/libs/font-awesome-4.2.0/css/font-awesome.min.css">
<style>

    body, html {
        height: 100%;
        width: 100%;
        margin: 0;
        padding: 0;
        background: #fafafa;
        color: #444;
    }

    body {
        font-family: sans-serif;
        display: flex;
        flex-direction: column;
    }

    canvas {
        flex: 1;
    }
</style>
<script>
require(['jQuery', 'THREE', 'libs/threejs/STLLoader', 'libs/threejs/postprocessing/EffectComposer',
            'libs/threejs/postprocessing/RenderPass', 'libs/threejs/postprocessing/ShaderPass',
            'libs/threejs/OrbitControls', 'libs/threejs/postprocessing/CopyShader'],
        function ($, THREE, STLLoader, EffectComposer, RenderPass, ShaderPass, OrbitControls, CopyShader) {
            var $container = $('body');
            var renderer = new THREE.WebGLRenderer({antialias: false, alpha: true, precision: 'highp', autoClear: true});
            $container.append(renderer.domElement);
            var outputWidth = $container.width();
            var outputHeight = $container.height();
            renderer.sortObjects = false;
            renderer.setSize(outputWidth, outputHeight);
            renderer.setViewport(0, 0, outputWidth, outputHeight);
            renderer.clear();
            new STLLoader().load('webapp/samples/soap.stl', function (geometry) {
                function draw() {
                    displayGeometry(geometry);
                }

                window.draw = draw;
                draw();
            });
            function createSphericalTool(sampleCount, zRatio, radiusMM) {
                var samples = [];
                var maxIndex = sampleCount - 1;
                for (var i = 0; i < sampleCount; i++) {
                    var relativeI = i / maxIndex;
                    samples.push((1 - Math.sqrt(1 - relativeI * relativeI)) * radiusMM * zRatio);
                }
                return samples;
            }

            function createVTool(sampleCount, zRatio, radiusMM) {
                var samples = [];
                for (var i = 0; i < sampleCount; i++)
                    samples.push(i / (sampleCount - 1) * radiusMM * zRatio);
                return samples;
            }

            function createCylindricalTool(sampleCount, zRatio, radiusMM) {
                var samples = [];
                for (var i = 0; i < sampleCount; i++)
                    samples.push(0);
                return samples;
            }

            function displayGeometry(geometry) {
                var scene = new THREE.Scene();
                var clonedGeometry = geometry.clone();
                var mesh = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({color: 0xFEEFFE}));
                scene.add(mesh);
                var pointsGeom = new THREE.BufferGeometry();
                // we add the vertices to force webgl to raster on at least 1 pixel
                // in case a "mountain" is spiky enough to slip thought the sampling grid.
                pointsGeom.addAttribute('position', geometry.attributes.position.clone());
                scene.add(new THREE.PointCloud(pointsGeom));
                // we should add all the edges too because a whole "ridge" might be sharp enough to slip through
                // the raster grid but I have a problem where the end of some lines "poke" slightly through the surface
                // I don't know why.
                // scene.add(new THREE.WireframeHelper(mesh));
                mesh.geometry.computeBoundingBox();
                var bbox = mesh.geometry.boundingBox;
                var bboxSize = mesh.geometry.boundingBox.size();
                var center = bbox.center();
                var modelRatio = bboxSize.y / bboxSize.x;
                var height = 512;
                var width = 512;
                var displayRatio = height / width;
                var ratio = displayRatio < modelRatio ? bboxSize.y / height : bboxSize.x / width;
                var partPixelsPerMm = 1 / ratio;
                var camera = new THREE.OrthographicCamera(-width / 2, width / 2, height / 2, -height / 2, 1, 100);
                scene.add(camera);
                console.log('partPixelsPerMm', partPixelsPerMm);
                camera.left = -width / 2 * ratio;
                camera.right = width / 2 * ratio;
                camera.top = height / 2 * ratio;
                camera.bottom = -height / 2 * ratio;
                camera.position.x = center.x;
                camera.position.y = center.y;
                camera.position.z = bbox.max.z + 1;
                camera.lookAt(center);
                camera.far = bbox.max.z - bbox.min.z + 1;
                console.log('near, far', camera.near, camera.far);
                camera.updateProjectionMatrix();
                var operation = {
                    sizeAttenuation: false,
                    linewidth: 1,
                    vertexShader: [
                        'void main() {',
                        '   gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);',
                        '}'].join('\n'),
                    // depth encoding : http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/
                    fragmentShader: [
                        'highp float factor = (exp2(24.0) - 1.0) / exp2(24.0);',
                        'vec3 EncodeFloatRGB(highp float v) {',
                        '   vec3 enc = fract(vec3(1.0, 255.0, 255.0 * 255.0) * factor * v);',
                        '   enc -= enc.yzz * vec3(1.0 / 255.0, 1.0 / 255.0, 0.0);',
                        '   return enc;',
                        '}',
                        'highp float DecodeFloatRGB(vec3 rgb) {',
                        '   return dot(rgb, vec3(1.0, 1.0 / 255.0, 1.0 / 255.0 / 255.0)) / factor;',
                        '}',
                        'void main() {',
                        '   gl_FragData[0] = vec4(EncodeFloatRGB((1.0 - gl_FragCoord.z)), 1.0);',
                        '}'].join('\n')
                };
                var target = new THREE.WebGLRenderTarget(width, height,
                        {minFilter: THREE.NearestFilter, magFilter: THREE.LinearFilter, type: THREE.FloatType });
                var composer = new EffectComposer(renderer, target);
                composer.addPass(new RenderPass(scene, camera, new THREE.ShaderMaterial(operation)));
                var toolRadiusMm = 1;
                var zRatio = 1 / (camera.far - camera.near);
                var toolPixelRadius = 16;
                var toolPixelsPerMm = toolPixelRadius / toolRadiusMm;
                var toolProfile = new Float32Array(createSphericalTool(toolPixelRadius, zRatio, toolRadiusMm));
                var toolTexture = new THREE.DataTexture(toolProfile, toolPixelRadius, 1, THREE.LuminanceFormat, THREE.FloatType);
                toolTexture.needsUpdate = true;
                console.log(toolPixelRadius);
                var shader = {
                    uniforms: {
                        tDiffuse: {type: 't', value: null},
                        toolProfile: {type: 't', value: toolTexture}
                    },
                    defines: {
                        toolToPartRatio: (toolPixelsPerMm / partPixelsPerMm).toPrecision(10),
                        pixelCount: toolPixelRadius,
                        w: (1.0 / width).toPrecision(10),
                        h: (1.0 / height).toPrecision(10)
                    },
                    vertexShader: [
                        'varying vec2 vUv;',
                        'void main() {',
                        '   vUv = uv;',
                        '   gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);',
                        '}'
                    ].join('\n'),
                    fragmentShader: [
                        'uniform sampler2D tDiffuse;',
                        'uniform sampler2D toolProfile;',
                        'varying vec2 vUv;',
                        'highp float factor = (exp2(24.0) - 1.0) / exp2(24.0);',
                        'vec3 EncodeFloatRGB(highp float v) {',
                        '   vec3 enc = fract(vec3(1.0, 255.0, 255.0 * 255.0) * factor * v);',
                        '   enc -= enc.yzz * vec3(1.0 / 255.0, 1.0 / 255.0, 0.0);',
                        '   return enc;',
                        '}',
                        'highp float DecodeFloatRGB(vec3 rgb) {',
                        '   return dot(rgb, vec3(1.0, 1.0 / 255.0, 1.0 / 255.0 / 255.0)) / factor;',
                        '}',
                        'highp float readHeight(vec2 pos) {',
                        '   highp vec4 color = texture2D(tDiffuse, vUv + pos * vec2(w, h) / toolToPartRatio);',
                        '   highp float displacement = texture2D(toolProfile, vec2(length(pos) / float(toolPixelRadius), 0.5)).r;',
                        '   return DecodeFloatRGB(color.rgb) - displacement;',
                        '}',
                        'void main() {',
                        '   highp int radiusSquared = toolPixelRadius * toolPixelRadius;',
                        '   highp float sum = readHeight(vec2(0.0, 0.0));',
                        '   for (int i = 0; i <= toolPixelRadius; i++)',
                        '       for (int j = 0; j <= toolPixelRadius; j++)',
                        '           if (i * i + j * j <= radiusSquared) {',
                        '               vec2 point = vec2(i, j);',
                        '               sum = max(sum, readHeight(point * vec2(-1.0, +1.0)));',
                        '               sum = max(sum, readHeight(point * vec2(+1.0, -1.0)));',
                        '               sum = max(sum, readHeight(point * vec2(-1.0, -1.0)));',
                        '               sum = max(sum, readHeight(point * vec2(+1.0, +1.0)));',
                        '           }',
                        '   gl_FragColor = vec4(sum, 0.0, 0.0, 1.0);',
                        '}'].join('\n')
                };
                var pass2 = new ShaderPass(shader);
                //pass2 = new ShaderPass(CopyShader);
                //pass2.renderToScreen = true;
                composer.addPass(pass2);
                composer.render();
                var scene2 = new THREE.Scene();
                var camera2 = new THREE.PerspectiveCamera(45, outputWidth / outputHeight, 0.01, 20000);
                camera2.up.set(0, 0, 1);
                camera2.position.z = 100;
                scene2.add(camera2);
                camera2.updateMatrixWorld();
                var directionalLight = new THREE.DirectionalLight(0xffffff, 1);
                directionalLight.position.set(1000, 1000, 1000);
                scene2.add(directionalLight);
                var directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.5);
                directionalLight2.position.set(-1000, -1000, 1000);
                scene2.add(directionalLight2);

                var terrainShader = {
                    wireframe: true,
                    size: 2,
                    uniforms: {
                        tDisplacement: {type: 't', value: composer.readBuffer},
                        xSpan: {type: 'f', value: camera.right - camera.left},
                        xCenter: {type: 'f', value: (camera.right - camera.left) / 2},
                        ySpan: {type: 'f', value: camera.top - camera.bottom},
                        yCenter: {type: 'f', value: (camera.top - camera.bottom) / 2},
                        farPlane: {type: 'f', value: camera.far - 1},
                        zRatio: {type: 'f', value: zRatio}
                    },
                    vertexShader: [
                        'uniform sampler2D tDisplacement;',
                        'uniform float xSpan;',
                        'uniform float xCenter;',
                        'uniform float ySpan;',
                        'uniform float yCenter;',
                        'uniform float farPlane;',
                        'uniform float zRatio;',
                        'varying vec4 color;',
                        'highp float factor = (exp2(24.0) - 1.0) / exp2(24.0);',
                        'vec3 EncodeFloatRGB(highp float v) {',
                        '   vec3 enc = fract(vec3(1.0, 255.0, 255.0 * 255.0) * factor* v);',
                        '   enc -= enc.yzz * vec3(1.0 / 255.0, 1.0 / 255.0, 0.0);',
                        '   return enc;',
                        '}',
                        'highp float DecodeFloatRGB(vec3 rgb) {',
                        '   return dot(rgb, vec3(1.0, 1.0 / 255.0, 1.0 / 255.0 / 255.0)) / factor;',
                        '}',
                        'void main() {',
                        '   float x = position.x * xSpan;',
                        '   float u = position.x + 0.5;',
                        '   float y = position.y * ySpan;',
                        '   float v = position.y + 0.5;',
                        '   color = texture2D(tDisplacement, vec2(u, v));',
                        '   gl_Position = projectionMatrix * modelViewMatrix * vec4(x, y, color.r / zRatio - farPlane, 1.0);',
                        '}'
                    ].join('\n'),
                    fragmentShader: [
                        'varying vec4 color;',
                        'void main() {',
                        '   gl_FragColor = vec4(color.r/2.0, color.g/2.0, color.r/2.0, 1.0);',
                        '}'].join('\n')
                };

                var terrainMaterial = new THREE.ShaderMaterial(terrainShader);

                function createGrid(xRes, yRes, points) {
                    var geometry = new THREE.BufferGeometry();
                    var vertices = [];
                    var offset = 0;

                    function pushVertex(i, j) {
                        vertices.push(i / xRes - 0.5, j / yRes - 0.5, 0);
                    }

                    for (var i = 0; i < xRes; i++)
                        for (var j = 0; j < yRes; j++) {
                            if (points)
                                pushVertex(i, j);
                            else {
                                if (i != 0) {
                                    pushVertex(i - 1, j);
                                    pushVertex(i, j);
                                }
                                if (j != 0) {
                                    pushVertex(i, j - 1);
                                    pushVertex(i, j);
                                }
                            }
                            offset += 3
                        }
                    geometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(vertices), 3));
                    if (points)
                        return new THREE.PointCloud(geometry, terrainMaterial);
                    else
                        return new THREE.Line(geometry, terrainMaterial, THREE.LinePieces);
                }

                var object = new THREE.LOD();
                object.addLevel(createGrid(1000, 1000, true), 20);
                object.addLevel(createGrid(500, 500, true), 50);
                object.addLevel(createGrid(100, 100), 75);
                object.updateMatrix();
                scene2.add(object);
                scene2.add(new THREE.Mesh(clonedGeometry, new THREE.MeshLambertMaterial({color: 0xFEEFFE, shading: THREE.SmoothShading})));

                var controls = new OrbitControls(camera2, renderer.domElement);
                controls.rotateSpeed = 1.0;
                controls.zoomSpeed = 1.2;
                controls.panSpeed = 0.8;
                controls.noZoom = false;
                controls.noPan = false;
                controls.staticMoving = true;
                controls.dynamicDampingFactor = 0.3;
                controls.minDistance = 3;
                controls.keys = [ 65, 83, 68 ];
                controls.addEventListener('change', function () {
                    reRender();
                });
                function reRender() {
                    object.update(camera2);
                    renderer.render(scene2, camera2);
                }

                reRender();

                function setToolType(type) {
                    console.time('tool change');
                    var types = {cylinder: createCylindricalTool, ball: createSphericalTool, v: createVTool};
                    pass2.material.uniforms.toolProfile.value.image.data.set(new Float32Array(types[type](toolPixelRadius, zRatio, toolRadiusMm)));
                    pass2.material.uniforms.toolProfile.value.needsUpdate = true;
                    console.time('complete render');
                    composer.render();
                    reRender();

                    //for pessimistic computation time measure, since gl.finish() is faked.
                    var gl = renderer.getContext();
                    gl.flush();
                    var pixelBuffer = new Uint8Array(4);
                    gl.readPixels(1, 1, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixelBuffer);
                    console.timeEnd('complete render');
                    console.timeEnd('tool change');
                }

                window.setToolType = setToolType;
            }
        });
</script>
</head>
<body>
<div>
    <select name="select" onChange="javascript:setToolType(this.value);">
        <option value="cylinder">Cylinder</option>
        <option value="ball" selected>Ball Nose</option>
        <option value="v">V Carving</option>
    </select>
</div>
</body>

</html>
