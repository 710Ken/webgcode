<!DOCTYPE html >
<html>
<head>
<meta http-equiv="X-UA-Compatible" content="chrome=1"/>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<title>Visual CAM</title>
<script src="webapp/libs/require.js"></script>
<script src="webapp/config.js"></script>
<script>
    requirejs.config({
        baseUrl: 'webapp'
    });
</script>
<link rel="shortcut icon" href="webapp/images/icon_fraise_48.png"/>
<link rel="stylesheet" href="webapp/twoDView.css" type="text/css">
<link rel="stylesheet" href="webapp/threeDView.css" type="text/css">
<link rel="stylesheet" href="webapp/libs/bootstrap/css/bootstrap.min.css">
<link rel="stylesheet" href="webapp/libs/font-awesome-4.2.0/css/font-awesome.min.css">
<style>

    body, html {
        height: 100%;
        width: 100%;
        margin: 0;
        padding: 0;
        background: #fafafa;
        color: #444;
    }

    body {
        font-family: sans-serif;
        display: flex;
        flex-direction: column;
    }

    canvas {
        flex: 1;
    }
</style>
<script>
require(['jQuery', 'THREE', 'libs/threejs/STLLoader', 'libs/threejs/postprocessing/EffectComposer',
            'libs/threejs/postprocessing/RenderPass', 'libs/threejs/postprocessing/ShaderPass',
            'libs/threejs/OrbitControls', 'libs/threejs/postprocessing/CopyShader'],
        function ($, THREE, STLLoader, EffectComposer, RenderPass, ShaderPass, OrbitControls, CopyShader) {
            var $container = $('body');
            var renderer = new THREE.WebGLRenderer({antialias: false, alpha: true, precision: 'highp', autoClear: true});
            $container.append(renderer.domElement);
            var outputWidth = $container.width();
            var outputHeight = $container.height();
            renderer.sortObjects = false;
            renderer.setSize(outputWidth, outputHeight);
            renderer.setViewport(0, 0, outputWidth, outputHeight);
            renderer.clear();
            new STLLoader().load('webapp/samples/soap.stl', function (geometry) {
                function draw() {
                    displayGeometry(geometry);
                }

                window.draw = draw;
                draw();
            });
            function createSphericalTool(sampleCount, zRatio, radiusMM) {
                var samples = [];
                var maxIndex = sampleCount - 1;
                for (var i = 0; i < sampleCount; i++) {
                    var relativeI = i / maxIndex;
                    samples.push((1 - Math.sqrt(1 - relativeI * relativeI)) * radiusMM * zRatio);
                }
                return samples;
            }

            function createVTool(sampleCount, zRatio, radiusMM) {
                var samples = [];
                for (var i = 0; i < sampleCount; i++)
                    samples.push(i / (sampleCount - 1) * radiusMM * zRatio);
                return samples;
            }

            function createCylindricalTool(sampleCount, zRatio, radiusMM) {
                var samples = [];
                for (var i = 0; i < sampleCount; i++)
                    samples.push(0);
                return samples;
            }

            function TerrainPipeline(geometry) {
                var scene = new THREE.Scene();
                var operation = {
                    sizeAttenuation: false,
                    linewidth: 1,
                    vertexShader: [
                        'void main() {',
                        '   gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);',
                        '}'].join('\n'),
                    // depth encoding : http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/
                    fragmentShader: [
                        'highp float factor = (exp2(24.0) - 1.0) / exp2(24.0);',
                        'vec3 EncodeFloatRGB(highp float v) {',
                        '   vec3 enc = fract(vec3(1.0, 255.0, 255.0 * 255.0) * factor * v);',
                        '   enc -= enc.yzz * vec3(1.0 / 255.0, 1.0 / 255.0, 0.0);',
                        '   return enc;',
                        '}',
                        'highp float DecodeFloatRGB(vec3 rgb) {',
                        '   return dot(rgb, vec3(1.0, 1.0 / 255.0, 1.0 / 255.0 / 255.0)) / factor;',
                        '}',
                        'void main() {',
                        '   gl_FragData[0] = vec4(EncodeFloatRGB((1.0 - gl_FragCoord.z)), 1.0);',
                        '}'].join('\n')
                };
                var mesh = new THREE.Mesh(geometry, new THREE.ShaderMaterial(operation));
                scene.add(mesh);

                var pointsGeom = new THREE.BufferGeometry();
                // we add the vertices to force webgl to raster on at least 1 pixel
                // in case a "mountain" is spiky enough to slip thought the sampling grid.
                pointsGeom.addAttribute('position', geometry.attributes.position.clone());
                scene.add(new THREE.PointCloud(pointsGeom, new THREE.ShaderMaterial($.extend({depthTest: true, size: 1, sizeAttenuation: false}, operation))));
                scene.add(new THREE.PointCloud(pointsGeom, new THREE.ShaderMaterial($.extend({depthTest: false, size: 1, sizeAttenuation: false}, operation))));
                // we should add all the edges too because a whole "ridge" might be sharp enough to slip through
                // the raster grid
                // I have a problem where the end of some lines "poke" slightly through the surface I don't know why.
                // question here: http://stackoverflow.com/questions/27097236/strange-artefacts-in-depth-buffer-with-lines
                // To mask the problem, I write the vertices (pointcloud above) on top of the wireframe without depth test, this will
                // squish all the buggy spikes. Since Three.js write from last to fist, I added the pointcloud first so it renders last.
                var wireframeHelper = new THREE.WireframeHelper(mesh);
                wireframeHelper.material = new THREE.ShaderMaterial(operation);
                scene.add(wireframeHelper);
                mesh.geometry.computeBoundingBox();
                var bbox = mesh.geometry.boundingBox;
                var bboxSize = mesh.geometry.boundingBox.size();
                var center = bbox.center();
                var modelRatio = bboxSize.y / bboxSize.x;
                //display grid is always square
                var displaySide = 512;
                var displaySideMm = 1 < modelRatio ? bboxSize.y : bboxSize.x;
                var halfDisplaySide = displaySideMm / 2;
                var camera = new THREE.OrthographicCamera(-halfDisplaySide, halfDisplaySide, halfDisplaySide, -halfDisplaySide, 1, 100);
                scene.add(camera);
                var sampleRate = displaySide / displaySideMm;
                camera.position.x = center.x;
                camera.position.y = center.y;
                camera.position.z = bbox.max.z + 1;
                camera.lookAt(center);
                camera.far = bbox.max.z - bbox.min.z + 1;
                console.log('near, far', camera.near, camera.far);
                camera.updateProjectionMatrix();

                var target = new THREE.WebGLRenderTarget(displaySide, displaySide,
                        {minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter});
                var composer = new EffectComposer(renderer, target);
                composer.addPass(new RenderPass(scene, camera));
                var toolRadiusMm = 1;
                var zRatio = 1 / (camera.far - camera.near);
                var toolShapePoints = 10;
                var radialSamples = Math.ceil(toolRadiusMm * sampleRate);
                console.log('radialSamples', radialSamples);
                var toolTexture = new THREE.DataTexture(new Float32Array(toolShapePoints), toolShapePoints, 1, THREE.LuminanceFormat, THREE.FloatType);
                var shader = {
                    uniforms: {
                        tDiffuse: {type: 't', value: null},
                        toolProfile: {type: 't', value: toolTexture},
                        toolToPartRatio: {type: 'f', value: toolRadiusMm / displaySideMm}
                    },
                    defines: {
                        radialSamples: radialSamples
                    },
                    vertexShader: [
                        'varying vec2 vUv;',
                        'void main() {',
                        '   vUv = uv;',
                        '   gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);',
                        '}'
                    ].join('\n'),
                    fragmentShader: [
                        'uniform sampler2D tDiffuse;',
                        'uniform sampler2D toolProfile;',
                        'uniform float toolToPartRatio;',
                        'varying vec2 vUv;',
                        'highp float factor = (exp2(24.0) - 1.0) / exp2(24.0);',
                        'vec3 EncodeFloatRGB(highp float v) {',
                        '   vec3 enc = fract(vec3(1.0, 255.0, 255.0 * 255.0) * factor * v);',
                        '   enc -= enc.yzz * vec3(1.0 / 255.0, 1.0 / 255.0, 0.0);',
                        '   return enc;',
                        '}',
                        'highp float DecodeFloatRGB(vec3 rgb) {',
                        '   return dot(rgb, vec3(1.0, 1.0 / 255.0, 1.0 / 255.0 / 255.0)) / factor;',
                        '}',
                        'highp float readHeight(vec2 pos) {',
                        '   highp vec4 color = texture2D(tDiffuse, vUv + pos * toolToPartRatio);',
                        '   highp float displacement = texture2D(toolProfile, vec2(length(pos), 0.0)).r;',
                        '   return DecodeFloatRGB(color.rgb) - displacement;',
                        '}',
                        'void main() {',
                        '   highp int radiusSquared = radialSamples * radialSamples;',
                        '   highp float sum = readHeight(vec2(0.0, 0.0));',
                        '   for (int i = -radialSamples; i <= radialSamples; i++)',
                        '       for (int j = -radialSamples; j <= radialSamples; j++)',
                        '           if (i * i + j * j <= radiusSquared)',
                        '               sum = max(sum, readHeight(vec2(i, j) / float(radialSamples)));',
                        '   gl_FragColor = vec4(EncodeFloatRGB(sum), 1.0);',
                        '}'].join('\n')
                };
                var pass2 = new ShaderPass(shader);
                //pass2 = new ShaderPass(CopyShader);
                //pass2.renderToScreen = true;
                composer.addPass(pass2);
                this.pass2 = pass2;
                this.composer = composer;
                this.toolPixelRadius = toolShapePoints;
                this.zRatio = zRatio;
                this.toolRadiusMm = toolRadiusMm;
                this.displaySideMm = displaySideMm;
                this.toolRadiusMm = toolRadiusMm;
                this.sampleRate = sampleRate;
                this.camera = camera;
                this.toolType = 'ball';
                this.updateToolShape();
            }

            TerrainPipeline.prototype = {
                render: function () {
                    this.composer.render();
                },
                getCameraData: function () {
                    var camera = this.camera;
                    return new THREE.Vector4((camera.right - camera.left) / 2, (camera.top - camera.bottom) / 2,
                            camera.right - camera.left, camera.top - camera.bottom);
                },
                updateToolShape: function () {
                    var types = {cylinder: createCylindricalTool, ball: createSphericalTool, v: createVTool};
                    var samples = types[this.toolType](this.toolPixelRadius, this.zRatio, this.toolRadiusMm);
                    this.pass2.material.uniforms.toolProfile.value.image.data.set(new Float32Array(samples));
                    this.pass2.material.uniforms.toolProfile.value.needsUpdate = true;
                },
                setToolType: function (type) {
                    this.toolType = type;
                    this.updateToolShape();
                },
                setToolRadius: function (radius) {
                    this.toolRadiusMm = radius;
                    this.updateToolShape();
                    this.pass2.material.defines.radialSamples = Math.ceil(radius * this.sampleRate);
                    this.pass2.material.uniforms.toolToPartRatio.value = (this.toolRadiusMm / this.displaySideMm).toPrecision(10);
                    this.pass2.material.needsUpdate = true;
                }
            };

            function displayGeometry(geometry) {
                var clonedGeometry = geometry.clone();
                var pipeline = new TerrainPipeline(geometry);
                var scene2 = new THREE.Scene();
                var camera2 = new THREE.PerspectiveCamera(45, outputWidth / outputHeight, 0.01, 20000);
                camera2.up.set(0, 0, 1);
                camera2.position.z = 100;
                scene2.add(camera2);
                camera2.updateMatrixWorld();
                var directionalLight = new THREE.DirectionalLight(0xffffff, 1);
                directionalLight.position.set(1000, 1000, 1000);
                scene2.add(directionalLight);
                var directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.5);
                directionalLight2.position.set(-1000, -1000, 1000);
                scene2.add(directionalLight2);

                var terrainShader = {
                    wireframe: true,
                    size: 2,
                    uniforms: {
                        tDisplacement: {type: 't', value: pipeline.composer.writeBuffer},
                        cameraXY: {type: 'v4', value: pipeline.getCameraData()},
                        farPlane: {type: 'f', value: pipeline.camera.far - 1},
                        zRatio: {type: 'f', value: pipeline.zRatio}
                    },
                    vertexShader: [
                        'uniform sampler2D tDisplacement;',
                        'uniform vec4 cameraXY;',
                        'uniform float farPlane;',
                        'uniform float zRatio;',
                        'varying vec4 color;',
                        'highp float factor = (exp2(24.0) - 1.0) / exp2(24.0);',
                        'vec3 EncodeFloatRGB(highp float v) {',
                        '   vec3 enc = fract(vec3(1.0, 255.0, 255.0 * 255.0) * factor* v);',
                        '   enc -= enc.yzz * vec3(1.0 / 255.0, 1.0 / 255.0, 0.0);',
                        '   return enc;',
                        '}',
                        'highp float DecodeFloatRGB(vec3 rgb) {',
                        '   return dot(rgb, vec3(1.0, 1.0 / 255.0, 1.0 / 255.0 / 255.0)) / factor;',
                        '}',
                        'void main() {',
                        '   float x = position.x * cameraXY.z;',
                        '   float u = position.x + 0.5;',
                        '   float y = position.y * cameraXY.w;',
                        '   float v = position.y + 0.5;',
                        '   color = texture2D(tDisplacement, vec2(u, v));',
                        '   gl_Position = projectionMatrix * modelViewMatrix * vec4(x, y, DecodeFloatRGB(color.rgb) / zRatio - farPlane, 1.0);',
                        '}'
                    ].join('\n'),
                    fragmentShader: [
                        'varying vec4 color;',
                        'void main() {',
                        '   gl_FragColor = vec4(color.r, 0.6 - abs(color.r - 0.5), 1.0 - color.r, 1.0);',
                        '}'].join('\n')
                };

                var terrainMaterial = new THREE.ShaderMaterial(terrainShader);

                function createGrid(xRes, yRes, points) {
                    var geometry = new THREE.BufferGeometry();
                    var vertices = [];
                    var offset = 0;

                    function pushVertex(i, j) {
                        vertices.push(i / xRes - 0.5, j / yRes - 0.5, 0);
                    }

                    for (var i = 0; i < xRes; i++)
                        for (var j = 0; j < yRes; j++) {
                            if (points)
                                pushVertex(i, j);
                            else {
                                if (i != 0) {
                                    pushVertex(i - 1, j);
                                    pushVertex(i, j);
                                }
                                if (j != 0) {
                                    pushVertex(i, j - 1);
                                    pushVertex(i, j);
                                }
                            }
                            offset += 3
                        }
                    geometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(vertices), 3));
                    if (points)
                        return new THREE.PointCloud(geometry, terrainMaterial);
                    else
                        return new THREE.Line(geometry, terrainMaterial, THREE.LinePieces);
                }

                var object = new THREE.LOD();
                object.addLevel(createGrid(512, 512, true), 50);
                object.addLevel(createGrid(100, 100), 75);
                object.updateMatrix();
                scene2.add(object);
                scene2.add(new THREE.Mesh(clonedGeometry, new THREE.MeshLambertMaterial({color: 0xFEEFFE, shading: THREE.SmoothShading})));

                var controls = new OrbitControls(camera2, renderer.domElement);
                controls.rotateSpeed = 1.0;
                controls.zoomSpeed = 1.2;
                controls.panSpeed = 0.8;
                controls.noZoom = false;
                controls.noPan = false;
                controls.staticMoving = true;
                controls.dynamicDampingFactor = 0.3;
                controls.minDistance = 3;
                controls.keys = [ 65, 83, 68 ];
                controls.addEventListener('change', function () {
                    reRender();
                });
                function reRender() {
                    object.update(camera2);
                    renderer.render(scene2, camera2);
                }

                function setToolType(type) {
                    console.time('tool change');
                    pipeline.setToolType(type);
                    reRenderPipeline();
                    console.timeEnd('tool change');
                }

                function setToolRadius(radius) {
                    $('#radius').text(radius);
                    console.time('tool change');
                    pipeline.setToolRadius(radius);
                    reRenderPipeline();
                    console.timeEnd('tool change');
                }

                function reRenderPipeline() {
                    console.time('complete render');
                    pipeline.composer.render();
                    reRender();

                    //for pessimistic computation time measure, since gl.finish() is faked.
                    var gl = renderer.getContext();
                    gl.flush();
                    var pixelBuffer = new Uint8Array(4);
                    gl.readPixels(1, 1, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixelBuffer);
                    console.timeEnd('complete render');
                }

                window.setToolType = setToolType;
                window.setToolRadius = setToolRadius;

                reRenderPipeline();
            }
        });
</script>
</head>
<body>
<div class="btn-toolbar" role="toolbar">
    <div class="btn-group" role="group">
        <label>shape: <select name="select" onChange="setToolType(this.value);">
            <option value="cylinder">Cylinder</option>
            <option value="ball" selected>Ball Nose</option>
            <option value="v">V Carving</option>
        </select></label>
        <label>Radius (<span id="radius">1</span>): <input type="range" min="0.1" max="10" value="1" step="0.1"
                                                           onchange="setToolRadius(this.value)"></label>
    </div>

</div>
</body>

</html>
